# 첫 시도

분할 했으므로 각 쓰레드가 맡는 지역이 있다. 

thread_i의 지역은 region_i이다. 각 region은 grid로 나눠진다. region_i = { grid_j | j \in 1..n }

grid는 인접 쓰레드가 관리하는 그리드와 같이 처리해야 할 경우가 있다. 
논리로 나누지 않고 그냥 일정 범위라고 가정하면 단순하고 편리하다. 

이들을 인접 그리드 중 소유자가 다른 그리드를 이웃 그리드라고 하고, grid'로 표시한다. 

grid'가 없을 경우는 그냥 처리하면 된다. 
grid'가 있을 경우는 인접 쓰레드와 serialize 해서 처리해야 한다. 
게임에서 상태 변경은 파괴적일 수 있기 때문에 일반적으로는 serialize해야 한다. 

그러면 이들 grid'를 포함한 쓰레드 thread'은 2차원에서 최대 3개가 될 수 있다. 
grid를 관리하는 쓰레드를 포함하면 4개이다. 이들을 thread, thread'_1, thread'_2, thread'_3 라고 하자. 

thread는 grid, grid'들을 찾기까지 이미 이벤트를 처리한 상태이기 때문에 
조율해서 처리할 수 있어야 한다. 이건 가정이며 resumable task인 fiber 같은 구조가 있다고 하면 
suspend와 resume으로 처리할 수도 있다. 더 복잡한 구조가 되므로 fiber 기반의 처리는 다음에 더 
생각해 보기로 한다. 

이벤트를 처리할 때 더 큰 정보에 접근해야 할 수 있다. thread'이 관리하는 더 많은 정보에 접근할 수 있다. 예를 들어, 사용자 정보를 얻어 오거나 해야 할 수 있다. 

각 thread가 갖고 있는 정보는 클래스로 구조화된다. 이들 정보가 공유되면 shared state multithreading이 된다. 

따라서, 정보가 분리되어야 하므로 각자 처리할 수 있어야 한다. 

event replication과 ghost object를 하나의 해결책으로 살펴간다. 

## Ghost Object and Event Replication 

지역 (region) 간 동기화 되어야 하는 모든 정보를 Event화 한다.
몬스터 스폰을 하면 SynSpawned를 thread'에 보낸다. 

이동, 공격, 아이템 장착과 해제 등 모두 그러하다. 

대단히 많은 이벤트가 있을 수 있으므로 각 thread 구현은 인접 쓰레드의 클라이언트처럼 동작할 수 있어야 한다. 

대단히 많은 수작업이 있을 수 있으므로 자동화 할 수 있는 방법이 있어야 한다.
시각적으로 인지 가능한 변화만 포함하므로 생각보다 적을 수도 있다. 

이 방향으로 끝까지 가본다. 




