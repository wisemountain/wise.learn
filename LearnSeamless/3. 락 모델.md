# 락 모델 

shared state multithreading을 사용하면 심리스 구현은 쉽다. 대신 락을 잘 처리해야 
구현도 편하고 성능도 올릴 수 있다. 

비동기 협업 모델은 메세지 전파에 공이 들어야 한다. 
정보 이동도 로컬, 리모트 나눠서 처리해야 한다. 

사용자가 메세지를 받아 현재 공간에 있는 정보를 사용하여 처리한다. Read / Write Lock이 
동시성을 올리는 데 중요하다. 

```c++
{
    grid_read_lock lock(region.grid);

    ...
}
```

grid와 인접 그리드에 대한 락. 

```c++
{
    object_write_lock lock(self);

    ...
}


lock은 핸들러들에서만 사용한다. timer와 이벤트를 처리하는 최상위 함수에서만 걸도록 한다. 
내부 container, object에서 락 처리를 하지 않는다. 

read phase와 write phase를 구분한다. 

핸들러 함수들은 길어질 가능성이 있으나 락 중심으로만 길게 하고 모듈화는 해야 한다. 


채널을 분리하고 채널 처리 전 락을 거는 건 도움이 될까? 그렇지는 않아 보인다. 
전체를 스핀락으로 구성할 수 있다. 대기는 타이머와 이벤트에 대해 한다. 



